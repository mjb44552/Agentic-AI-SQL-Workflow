from typing import List,Optional

from sqlalchemy.orm import sessionmaker
from pandas import DataFrame

from agno.tools import Toolkit

from data_processing import resort_traits_data

from sqlalchemy.types import INTEGER, FLOAT, BOOLEAN, TEXT
from sqlalchemy import text, create_engine, Engine

class ski_resort_traits_sql_toolkit(Toolkit):
    """
    A toolkit for interacting with a SQL database containing ski resort traits.
    """

    def __init__(self, db_user: str = 'ski_resorts_db',
                 db_password: str = 'ski_resorts_db',
                 db_host: str = 'localhost',
                 db_port: str = '5433',
                 db_name: str = 'ski_resorts_db',
                 table_name: str = 'resort_traits',
                 custom_dtype_dict: Optional[dict] = None):
        """
        Initializes the SkiResortTraitsSQLToolkit with database connection details.

        Parameters:
            db_user (str): Database username.
            db_password (str): Database password.
            db_host (str): Database host.
            db_port (str): Database port.
            db_name (str): Database name.
            table_name (str): Table name in the database.
            custom_dtype_dict (dict,optional): Dictionary mapping column names to SQLAlchemy types.
        """
        super().__init__(name="ski_resort_sql_tools",tools=[self.query_ski_resort_traits_database,self.update_ski_resort_traits_database])
        
        self.db_user = db_user
        self.db_password = db_password
        self.db_host = db_host
        self.db_port = db_port
        self.db_name = db_name
        self.table_name = table_name

        # Handle mutable default argument for custom_dtype_dict

        # As custom_dtype_dict is mutable if a new dictionary is provided then all other instances use the new dictionary. 
        # setting custom_dtype_dict to None and then initialising in consturctor means by default all instances will use the same dictionary.
        # #Even if one dictionary has been changed. 
        if custom_dtype_dict is None:
            self.custom_dtype_dict = {
                'name': TEXT,
                'country': TEXT,
                'status': TEXT,
                'has_downhill': BOOLEAN,
                'has_nordic': BOOLEAN,
                'downhill_distance_km': FLOAT,
                'nordic_distance_km': FLOAT,
                'vertical_m': FLOAT,
                'min_elevation_m': FLOAT,
                'max_elevation_m': FLOAT,
                'lift_count': INTEGER
            }
        else:
            self.custom_dtype_dict = custom_dtype_dict

    def get_db_engine(self)-> Engine:
        """Helper method to get a new SQLAlchemy engine."""
        connection_string = f"postgresql+psycopg2://{self.db_user}:{self.db_password}@{self.db_host}:{self.db_port}/{self.db_name}"
        return create_engine(connection_string)
    
    def update_ski_resort_traits_database(self, data:DataFrame = resort_traits_data):
        """
        Update the ski resort traits database with new data.

        Parameters:
            data (pd.DataFrame): The data to update the database with.
        """
        engine = self.get_db_engine()
        resort_traits_data.to_sql(name=self.table_name, con=engine, if_exists='replace', index=False, dtype= self.custom_dtype_dict)

    def query_ski_resort_traits_database(self, query: str) -> List[dict]:
        """
        Execute a SQL query on the ski resort traits database to extract data useful
        for making ski resort recommendations.

        Parameters:
            query (str): The SQL query to execute in the form of a multi-line string. This query is generated by the AI agent.

        Returns:
            List[dict]: The result of the query as a list of dictionaries.
        """
        engine = self.get_db_engine()

        #creating a sql session with sql engine 
        Session = sessionmaker(bind=engine)
        session = Session()

        #execute query 
        result = session.execute(text(query))

        #write result into a list of dictionaries
        column_names = result.keys()
        rows_as_dicts = []
        for row in result:
            row_dict = {col_name: row[col_name] for col_name in column_names}
            rows_as_dicts.append(row_dict)

        #drop connection to database
        session.close()
        engine.dispose()

        return rows_as_dicts




